<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Drawio Collaboration</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b0c10; color: #e5e5e5; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header { padding: 10px 12px; background: #1f2833; display: flex; align-items: center; justify-content: space-between; }
    .row { display: flex; gap: 8px; align-items: center; }
    .badge { padding: 2px 6px; border-radius: 100px; background: #233042; font-size: 12px; }
    #editor { width: 100%; height: calc(100% - 48px); border: 0; display: block; }
    button, a { background: #0e1116; color: #e5e5e5; border: 1px solid #2f3742; border-radius: 8px; padding: 8px 10px; text-decoration: none; }
    #stage { position: relative; width: 100%; height: calc(100% - 48px); }
    #overlay { position: absolute; inset: 0; pointer-events: none; }
    .cursor {
      position: absolute;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0);
      pointer-events: none;
    }
    .cursor .dot {
      width: 10px; height: 10px; border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 0 0 2px rgba(0,0,0,0.4);
    }
    .cursor .label {
      position: absolute; top: 12px; left: 8px;
      padding: 2px 6px; font-size: 11px; border-radius: 6px;
      background: rgba(0,0,0,0.6); color: white;
      white-space: nowrap;
    }
    .cursor .sel {
      position: absolute; top: -16px; left: 8px;
      padding: 1px 6px; font-size: 10px; border-radius: 6px;
      background: rgba(0,0,0,0.6); color: #cbd5e1;
      white-space: nowrap;
      display: none;
    }
    .cursor .sel {
      position: absolute; top: -16px; left: 8px;
      padding: 1px 6px; font-size: 10px; border-radius: 6px;
      background: rgba(0,0,0,0.6); color: #cbd5e1;
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <header>
    <div class="row">
      <strong id="file">Loading...</strong>
      <span class="badge" id="user">guest</span>
      <span class="badge" id="status">Connecting...</span>
      <span class="badge" id="version">v0</span>
    </div>
    <div class="row">
      <a href="/" id="back">Back</a>
    </div>
  </header>
  <div id="stage">
    <iframe id="editor" allow="fullscreen" src="/diagrams/index.html?embed=1&ui=min&proto=json&spin=1&noDevice=1&saveAndExit=1&xml=1"></iframe>
    <div id="overlay"></div>
  </div>
  <script>
    const $ = (id) => document.getElementById(id);
    const params = new URLSearchParams(location.search);
    const fileName = params.get('name');
    $('file').textContent = fileName || '(no file)';
    $('back').href = '/';

    let ws = null;
    let currentVersion = 0;
    let isEditorReady = false;
    let lastXml = '';
    let selfUpdateToken = 0; // increments on our own WS sends to detect self echoes (best-effort)
    let myUsername = 'guest';
    let myClientId = null;
    const cursors = new Map(); // username -> {el, color, selEl}
    let lastEmbedMoveAt = 0;

    async function refreshMe() {
      try {
        const res = await fetch('/me', { credentials: 'include' });
        if (res.ok) {
          const me = await res.json();
          $('user').textContent = me.username;
          myUsername = me.username;
        } else {
          $('user').textContent = 'guest';
          myUsername = 'guest';
        }
      } catch {}
    }

    async function loadInitial() {
      if (!fileName) return;
      const resp = await fetch(`/files/${encodeURIComponent(fileName)}`, { credentials: 'include' });
      if (!resp.ok) throw new Error(await resp.text());
      const meta = await resp.json();
      currentVersion = meta.version || 0;
      $('version').textContent = 'v' + currentVersion;
      lastXml = meta.content || '';
      // If editor already ready, push content
      if (isEditorReady) {
        postToEditor({ action: 'load', autosave: 1, modified: 'unsavedChanges', xml: lastXml, title: fileName });
      }
    }

    function connectWS() {
      if (!fileName) return;
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      ws = new WebSocket(`${proto}://${location.host}/ws/${encodeURIComponent(fileName)}`);
      ws.onopen = () => { $('status').textContent = 'Connected'; };
      ws.onclose = () => { $('status').textContent = 'Disconnected'; };
      ws.onerror = () => { $('status').textContent = 'Error'; };
      ws.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          if (msg.type === 'init') {
            currentVersion = msg.version || 0;
            $('version').textContent = 'v' + currentVersion;
            lastXml = msg.content || '';
            if (msg.your_id) { myClientId = msg.your_id; }
            if (isEditorReady) {
              postToEditor({ action: 'load', autosave: 1, modified: 'unsavedChanges', xml: lastXml, title: fileName });
            }
          } else if (msg.type === 'presence_snapshot') {
            for (const u of msg.users || []) {
              ensureCursor(u.username, u.color);
            }
          } else if (msg.type === 'presence_join') {
            ensureCursor(msg.username, msg.color);
          } else if (msg.type === 'presence_leave') {
            removeCursor(msg.username);
          } else if (msg.type === 'cursor') {
            const fromSelf = (msg.sender_id && myClientId && msg.sender_id === myClientId) || (msg.username && msg.username === myUsername);
            if (!fromSelf) { moveCursor(msg.username, msg.x, msg.y, msg.basis); }
          } else if (msg.type === 'selection') {
            const fromSelf = (msg.sender_id && myClientId && msg.sender_id === myClientId) || (msg.username && msg.username === myUsername);
            if (!fromSelf) {
              const c = cursors.get(msg.username);
              if (c) {
                const n = (msg.ids || []).length;
                c.selEl.style.display = n > 0 ? 'block' : 'none';
                c.selEl.textContent = n > 0 ? `${n} selected` : '';
              }
            }
          } else if (msg.type === 'update') {
            const fromSelf = (msg.sender_id && myClientId && msg.sender_id === myClientId) || false;
            if (fromSelf) { return; }
            currentVersion = msg.version || currentVersion;
            $('version').textContent = 'v' + currentVersion;
            if (msg.content && msg.content !== lastXml) {
              lastXml = msg.content;
              // Try merge first; editor will attempt in-place merge with unsaved changes.
              // Fallback: reload if merge is not supported by the embed.
              try {
                postToEditor({ action: 'merge', xml: lastXml });
              } catch {
                postToEditor({ action: 'load', autosave: 1, modified: 'unsavedChanges', xml: lastXml, title: fileName });
              }
            }
          }
        } catch (e) {
          console.error('bad ws message', e, ev.data);
        }
      };
    }

    function editorOrigin() {
      const iframe = $('editor');
      try {
        const url = new URL(iframe.getAttribute('src'), window.location.origin);
        return url.origin;
      } catch {
        return window.location.origin;
      }
    }
    function postToEditor(msg) {
      const iframe = $('editor');
      iframe.contentWindow.postMessage(JSON.stringify(msg), editorOrigin());
    }

    // If the iframe is same-origin (when you self-host draw.io), attach direct mouse tracking for precise cursors
    function attachSameOriginMouseTracking() {
      const iframe = $('editor');
      try {
        const childWin = iframe.contentWindow;
        const childDoc = childWin.document;
        // Accessing childDoc will throw if cross-origin; guard with try/catch
        if (!childDoc) return;
        let lastSentLocal = 0;
        childDoc.addEventListener('mousemove', (e) => {
          if (!ws || ws.readyState !== WebSocket.OPEN) return;
          const now = performance.now();
          if (now - lastSentLocal < 33) return;
          lastSentLocal = now;
          // Prefer coordinates relative to the drawing stage to remove toolbar offsets
          const stage = childDoc.querySelector('.geDiagramContainer') || childDoc.querySelector('#geDiagramContainer');
          if (stage) {
            const stageRect = stage.getBoundingClientRect();
            const nx = Math.max(0, Math.min(1, (e.clientX - stageRect.left) / Math.max(1, stageRect.width)));
            const ny = Math.max(0, Math.min(1, (e.clientY - stageRect.top) / Math.max(1, stageRect.height)));
            ws.send(JSON.stringify({ type: 'cursor', basis: 'stage', x: nx, y: ny }));
          } else {
            const overlayRect = $('overlay').getBoundingClientRect();
            const iframeRect = iframe.getBoundingClientRect();
            const absX = iframeRect.left + e.clientX;
            const absY = iframeRect.top + e.clientY;
            const nx = Math.max(0, Math.min(1, (absX - overlayRect.left) / Math.max(1, overlayRect.width)));
            const ny = Math.max(0, Math.min(1, (absY - overlayRect.top) / Math.max(1, overlayRect.height)));
            ws.send(JSON.stringify({ type: 'cursor', x: nx, y: ny }));
          }
        }, { passive: true });
      } catch {
        // Not same-origin; ignore
      }
    }

    // Listen to messages from the editor
    let waitingExportForSave = false;

    window.addEventListener('message', async (evt) => {
      // Must be stringified JSON
      let data = null;
      try {
        data = JSON.parse(evt.data);
      } catch {
        return;
      }
      // Editor ready lifecycle
      if (data.event === 'init' || data.action === 'init') {
        isEditorReady = true;
        // Load initial xml once editor is ready
        if (lastXml !== null) {
          postToEditor({ action: 'load', autosave: 1, modified: 'unsavedChanges', xml: lastXml, title: fileName });
        }
        // Request event stream (selection/mouse) from embed
        try {
          postToEditor({ action: 'configure', config: { listen: true, events: true, eventsEnabled: true } });
        } catch {}
        // Try to attach direct listeners if same-origin
        attachSameOriginMouseTracking();
        return;
      }
      // Selection changes from editor (best-effort API)
      if (data.event === 'selectionChanged' && Array.isArray(data.cells)) {
        try {
          if (ws && ws.readyState === WebSocket.OPEN) {
            const ids = data.cells.map(c => (c && typeof c === 'object') ? (c.id || '') : (typeof c === 'string' ? c : '')).filter(Boolean);
            ws.send(JSON.stringify({ type: 'selection', ids }));
          }
        } catch {}
      }
      // Mouse move events from embed; forward if present
      if ((data.event === 'mouseMove' || data.event === 'mousemove' || data.action === 'mouseMove') && typeof data.x === 'number' && typeof data.y === 'number') {
        try {
          if (ws && ws.readyState === WebSocket.OPEN) {
            const rect = $('overlay').getBoundingClientRect();
            const nx = Math.max(0, Math.min(1, (data.x - rect.left) / Math.max(1, rect.width)));
            const ny = Math.max(0, Math.min(1, (data.y - rect.top) / Math.max(1, rect.height)));
            ws.send(JSON.stringify({ type: 'cursor', x: nx, y: ny }));
            lastEmbedMoveAt = performance.now();
          }
        } catch {}
      }
      // The editor asks us to save current XML
      if (data.event === 'save' || data.action === 'save' || data.event === 'autosave') {
        try {
          $('status').textContent = 'Saving...';
          let xml = data.xml || '';
          // Fallback path: request export if xml not provided
          if (!xml) {
            waitingExportForSave = true;
            postToEditor({ action: 'export', format: 'xml' });
            return; // continue when we receive export
          }
          lastXml = xml;
          // Broadcast via WS
          if (ws && ws.readyState === WebSocket.OPEN) {
            selfUpdateToken++;
            ws.send(JSON.stringify({ type: 'replace', version: currentVersion, content: xml, self: selfUpdateToken }));
          }
          // Persist via HTTP
          const resp = await fetch(`/files/${encodeURIComponent(fileName)}`, {
            method: 'PUT',
            credentials: 'include',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content: xml }),
          });
          if (!resp.ok) {
            const msg = await resp.text();
            $('status').textContent = `Save failed: ${msg || resp.status}`;
            return;
          }
          $('status').textContent = 'Saved';
          postToEditor({ action: 'saved' });
          return;
        } catch (e) {
          $('status').textContent = `Save error`;
          return;
        }
      }
      // Editor export response (used when xml not included in save/autosave)
      if (data.event === 'export') {
        if (waitingExportForSave) {
          waitingExportForSave = false;
          const xml = data.data || data.xml || '';
          if (!xml) {
            $('status').textContent = 'Export failed';
            return;
          }
          (async () => {
            try {
              lastXml = xml;
              if (ws && ws.readyState === WebSocket.OPEN) {
                selfUpdateToken++;
                ws.send(JSON.stringify({ type: 'replace', version: currentVersion, content: xml, self: selfUpdateToken }));
              }
              const resp = await fetch(`/files/${encodeURIComponent(fileName)}`, {
                method: 'PUT',
                credentials: 'include',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ content: xml }),
              });
              if (!resp.ok) {
                const msg = await resp.text();
                $('status').textContent = `Save failed: ${msg || resp.status}`;
                return;
              }
              $('status').textContent = 'Saved';
              postToEditor({ action: 'saved' });
            } catch {
              $('status').textContent = 'Save error';
            }
          })();
          return;
        }
      }
      // Exit from editor
      if (data.event === 'exit' || data.action === 'exit') {
        location.href = '/';
        return;
      }
    });

    $('editor').addEventListener('load', () => {
      // Attempt same-origin tracking as soon as the iframe loads
      attachSameOriginMouseTracking();
      // The editor will send 'init' shortly; we don't send 'load' until then
    });

    // Presence cursors
    function ensureCursor(username, color) {
      if (username === myUsername) return;
      if (cursors.has(username)) return;
      const el = document.createElement('div');
      el.className = 'cursor';
      const dot = document.createElement('div');
      dot.className = 'dot';
      dot.style.background = color;
      dot.style.borderColor = color;
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = username;
      const selEl = document.createElement('div');
      selEl.className = 'sel';
      selEl.style.display = 'none';
      el.appendChild(dot);
      el.appendChild(label);
      el.appendChild(selEl);
      $('overlay').appendChild(el);
      cursors.set(username, { el, color, selEl });
    }
    function removeCursor(username) {
      const c = cursors.get(username);
      if (!c) return;
      c.el.remove();
      cursors.delete(username);
    }
    function getOverlayStageRect() {
      const iframe = $('editor');
      try {
        const childDoc = iframe.contentWindow.document;
        const stage = childDoc.querySelector('.geDiagramContainer') || childDoc.querySelector('#geDiagramContainer');
        if (!stage) return null;
        const iframeRect = iframe.getBoundingClientRect();
        const stageRect = stage.getBoundingClientRect();
        const overlayRect = $('overlay').getBoundingClientRect();
        return {
          left: (iframeRect.left + stageRect.left) - overlayRect.left,
          top: (iframeRect.top + stageRect.top) - overlayRect.top,
          width: stageRect.width,
          height: stageRect.height
        };
      } catch { return null; }
    }

    function moveCursor(username, nx, ny, basis) {
      const c = cursors.get(username);
      if (!c) return;
      const overlay = $('overlay');
      const rect = overlay.getBoundingClientRect();
      let x, y;
      if (basis === 'stage') {
        const s = getOverlayStageRect();
        if (s) {
          x = s.left + nx * s.width;
          y = s.top + ny * s.height;
        } else {
          x = nx * rect.width;
          y = ny * rect.height;
        }
      } else {
        x = nx * rect.width;
        y = ny * rect.height;
      }
      c.el.style.left = x + 'px';
      c.el.style.top = y + 'px';
    }
    // Fallback: parent-document tracking for when embed doesn't emit mouseMove
    let lastSent = 0;
    document.addEventListener('mousemove', (e) => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      const now = performance.now();
      // If we recently received an embed mouse event, skip fallback to avoid double-sends
      if (now - lastEmbedMoveAt < 80) return;
      if (now - lastSent < 33) return; // ~30fps throttle
      const overlay = $('overlay');
      const rect = overlay.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (x < 0 || y < 0 || x > rect.width || y > rect.height) return;
      lastSent = now;
      const nx = x / Math.max(1, rect.width);
      const ny = y / Math.max(1, rect.height);
      ws.send(JSON.stringify({ type: 'cursor', x: nx, y: ny }));
    });

    refreshMe();
    loadInitial().then(connectWS);
  </script>
</body>
</html>


