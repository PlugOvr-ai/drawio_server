<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Drawio Collaboration</title>
  <style>
    html, body { height: 100%; margin: 0; background: #ffffff; color: #111827; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header { padding: 10px 12px; background: #f8fafc; border-bottom: 1px solid #e5e7eb; display: flex; align-items: center; justify-content: space-between; }
    .row { display: flex; gap: 8px; align-items: center; }
    .badge { padding: 2px 6px; border-radius: 100px; background: #eef2ff; color: #1e3a8a; font-size: 12px; }
    #editor { width: 100%; height: calc(100% - 48px); border: 0; display: block; }
    button, a { background: #ffffff; color: #111827; border: 1px solid #e5e7eb; border-radius: 8px; padding: 8px 10px; text-decoration: none; }
    #stage { position: relative; width: 100%; height: calc(100% - 48px); }
    #overlay { position: absolute; inset: 0; pointer-events: none; }
    .cursor {
      position: absolute;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0);
      pointer-events: none;
    }
    .cursor .dot {
      width: 10px; height: 10px; border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 0 0 2px rgba(0,0,0,0.4);
    }
    .cursor .label {
      position: absolute; top: 12px; left: 8px;
      padding: 2px 6px; font-size: 11px; border-radius: 6px;
      background: rgba(255,255,255,0.9); color: #111827; border: 1px solid #e5e7eb;
      white-space: nowrap;
    }
    .cursor .sel {
      position: absolute; top: -16px; left: 8px;
      padding: 1px 6px; font-size: 10px; border-radius: 6px;
      background: rgba(255,255,255,0.9); color: #374151; border: 1px solid #e5e7eb;
      white-space: nowrap;
      display: none;
    }
    .cursor .sel {
      position: absolute; top: -16px; left: 8px;
      padding: 1px 6px; font-size: 10px; border-radius: 6px;
      background: rgba(255,255,255,0.9); color: #374151; border: 1px solid #e5e7eb;
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <header>
    <div class="row">
      <strong id="file">Loading...</strong>
      <span class="badge" id="user">guest</span>
      <span class="badge" id="status">Connecting...</span>
      <span class="badge" id="version">v0</span>
    </div>
    <div class="row">
      <input type="text" id="commit-message" placeholder="Commit message (optional)" style="padding: 6px 10px; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 13px; width: 200px;" />
      <button id="commit-btn">Commit</button>
      <a href="/" id="back">Back</a>
      <button id="ai-open">AI Modify</button>
    </div>
  </header>
  <div id="stage">
    <iframe id="editor" allow="fullscreen" src="/diagrams/index.html?embed=1&ui=min&proto=json&spin=1&noDevice=1&saveAndExit=1&xml=1"></iframe>
    <div id="overlay"></div>
  </div>
  <div id="ai-activity" style="display:none; position: fixed; right: 12px; top: 60px; width: 320px; max-height: 40vh; overflow: auto; background: #ffffff; border: 1px solid #e5e7eb; border-radius: 10px; padding: 8px; box-shadow: 0 8px 24px rgba(0,0,0,0.08); z-index: 80;">
    <div style="display:flex; align-items:center; justify-content: space-between; margin-bottom: 6px;">
      <strong style="font-size: 13px;">AI activity</strong>
      <button id="ai-activity-close" style="font-size:12px;">Hide</button>
    </div>
    <div id="ai-activity-log" style="font-size: 12px; color:#374151; display:grid; gap:4px;"></div>
    <pre id="ai-activity-stream" style="margin-top:6px; background:#f9fafb; border:1px solid #e5e7eb; border-radius:8px; padding:8px; font-size:12px; color:#111827; white-space:pre-wrap; word-break:break-word; max-height:22vh; overflow:auto;"></pre>
  </div>
  <!-- AI Modal -->
  <div id="ai-backdrop" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.35); z-index: 60;"></div>
  <div id="ai-modal" style="display:none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: min(720px, 94vw); background: #ffffff; border: 1px solid #e5e7eb; border-radius: 10px; padding: 12px; z-index: 70;">
    <div style="display:flex; align-items:center; justify-content: space-between; margin-bottom: 8px;">
      <strong>AI Modify Diagram</strong>
      <button id="ai-close">Close</button>
    </div>
    <div style="display:grid; gap: 8px;">
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 8px;">
        <label style="display:grid; gap:4px;">
          <span style="font-size:12px; color:#6b7280;">Provider</span>
          <select id="ai-provider">
            <option value="openrouter">OpenRouter</option>
            <option value="ollama">Ollama</option>
          </select>
        </label>
        <label style="display:grid; gap:4px;">
          <span style="font-size:12px; color:#6b7280;">Model</span>
          <input id="ai-model" placeholder="e.g., openrouter/anthropic/claude-3.5-sonnet or llama3.1:latest" />
        </label>
      </div>
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 8px;">
        <label style="display:grid; gap:4px;">
          <span style="font-size:12px; color:#6b7280;">Temperature (optional)</span>
          <input id="ai-temp" placeholder="e.g., 0.2" />
        </label>
        <label style="display:grid; gap:4px;">
          <span style="font-size:12px; color:#6b7280;">System prompt (optional)</span>
          <input id="ai-system" placeholder="Override system instruction (optional)" />
        </label>
      </div>
      <label style="display:grid; gap:4px;">
        <span style="font-size:12px; color:#6b7280;">Instruction</span>
        <textarea id="ai-prompt" rows="8" placeholder="Describe how to modify the diagram (add nodes/edges, rename, layout changes, etc.)" style="width:100%;"></textarea>
      </label>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button id="ai-run">Run</button>
      </div>
      <div id="ai-hint" style="font-size:12px; color:#6b7280;">OpenRouter requires environment variable OPENROUTER_API_KEY on the server. Ollama defaults to http://localhost:11434 (override with OLLAMA_URL).</div>
    </div>
  </div>
  <script>
    const $ = (id) => document.getElementById(id);
    const params = new URLSearchParams(location.search);
    const filePath = params.get('path') || params.get('name');
    $('file').textContent = filePath || '(no file)';
    
    // Store token from URL if present
    const urlToken = params.get('token');
    if (urlToken) {
      localStorage.setItem('drawio_token', urlToken);
      // Clean URL to remove token from address bar for security
      const url = new URL(location);
      url.searchParams.delete('token');
      history.replaceState({}, '', url);
    }
    
    // Set back button with token
    const storedToken = localStorage.getItem('drawio_token');
    $('back').href = storedToken ? `/?token=${encodeURIComponent(storedToken)}` : '/';

    let ws = null;
    let currentVersion = 0;
    let isEditorReady = false;
    let lastXml = '';
    let selfUpdateToken = 0; // increments on our own WS sends to detect self echoes (best-effort)
    let myUsername = 'guest';
    let myClientId = null;
    const cursors = new Map(); // username -> {el, color, selEl}
    let lastEmbedMoveAt = 0;
    const aiJobs = new Map(); // job_id -> {lastPhase, createdAt}
    
    // Helper function to add token to URLs
    function addTokenToUrl(url) {
      const storedToken = localStorage.getItem('drawio_token');
      if (!storedToken) return url;
      const separator = url.includes('?') ? '&' : '?';
      return `${url}${separator}token=${encodeURIComponent(storedToken)}`;
    }

    async function refreshMe() {
      try {
        const res = await fetch(addTokenToUrl('/me'), { credentials: 'include' });
        if (res.ok) {
          const me = await res.json();
          $('user').textContent = me.username;
          myUsername = me.username;
        } else {
          $('user').textContent = 'guest';
          myUsername = 'guest';
          // If unauthorized, redirect to login
          if (res.status === 401) {
            $('status').textContent = 'Authentication required';
            setTimeout(() => {
              location.href = '/token.html';
            }, 1500);
          }
        }
      } catch {}
    }

    async function loadInitial() {
      if (!filePath) return;
      const url = addTokenToUrl(`/api/file?path=${encodeURIComponent(filePath)}`);
      const resp = await fetch(url, { credentials: 'include' });
      if (!resp.ok) {
        if (resp.status === 401) {
          // Unauthorized - redirect to login
          $('status').textContent = 'Authentication required';
          setTimeout(() => {
            location.href = '/token.html';
          }, 1500);
          return;
        }
        throw new Error(await resp.text());
      }
      const meta = await resp.json();
      currentVersion = meta.version || 0;
      $('version').textContent = 'v' + currentVersion;
      lastXml = meta.content || '';
      // If editor already ready, push content
      if (isEditorReady) {
        postToEditor({ action: 'load', autosave: 1, xml: lastXml, title: filePath });
      }
    }

    function connectWS() {
      if (!filePath) return;
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      // Include token from localStorage if available for re-authentication
      let wsUrl = `${proto}://${location.host}/ws/_?path=${encodeURIComponent(filePath)}`;
      const storedToken = localStorage.getItem('drawio_token');
      if (storedToken) {
        wsUrl += `&token=${encodeURIComponent(storedToken)}`;
      }
      ws = new WebSocket(wsUrl);
      ws.onopen = () => { $('status').textContent = 'Connected'; };
      ws.onclose = (evt) => { 
        $('status').textContent = 'Disconnected';
        // If connection closed with 1008 (policy violation, usually auth failure), redirect to login
        if (evt.code === 1008 || evt.code === 1002 || evt.code === 1003) {
          $('status').textContent = 'Authentication expired';
          setTimeout(() => {
            location.href = '/token.html';
          }, 1500);
        }
      };
      ws.onerror = (evt) => { 
        $('status').textContent = 'Connection error';
        // WebSocket connection failed - likely authentication issue
        // Wait a moment to see if we get more info, then check if it's auth
        setTimeout(async () => {
          if (ws.readyState !== WebSocket.OPEN) {
            // Try a simple API call to check authentication
            try {
              const testResp = await fetch('/me', { credentials: 'include' });
              if (testResp.status === 401) {
                $('status').textContent = 'Authentication required';
                setTimeout(() => {
                  location.href = '/token.html';
                }, 1000);
              }
            } catch (e) {
              // Network error or other issue
              console.error('Error checking auth:', e);
            }
          }
        }, 500);
      };
      ws.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          if (msg.type === 'init') {
            currentVersion = msg.version || 0;
            $('version').textContent = 'v' + currentVersion;
            lastXml = msg.content || '';
            if (msg.your_id) { myClientId = msg.your_id; }
            if (isEditorReady) {
              postToEditor({ action: 'load', autosave: 1, xml: lastXml, title: filePath });
            }
          } else if (msg.type === 'presence_snapshot') {
            for (const u of msg.users || []) {
              ensureCursor(u.username, u.color);
            }
          } else if (msg.type === 'presence_join') {
            ensureCursor(msg.username, msg.color);
          } else if (msg.type === 'presence_leave') {
            removeCursor(msg.username);
          } else if (msg.type === 'cursor') {
            const fromSelf = (msg.sender_id && myClientId && msg.sender_id === myClientId) || (msg.username && msg.username === myUsername);
            if (!fromSelf) { moveCursor(msg.username, msg.x, msg.y, msg.basis); }
          } else if (msg.type === 'selection') {
            const fromSelf = (msg.sender_id && myClientId && msg.sender_id === myClientId) || (msg.username && msg.username === myUsername);
            if (!fromSelf) {
              const c = cursors.get(msg.username);
              if (c) {
                const n = (msg.ids || []).length;
                c.selEl.style.display = n > 0 ? 'block' : 'none';
                c.selEl.textContent = n > 0 ? `${n} selected` : '';
              }
            }
          } else if (msg.type === 'update') {
            const fromSelf = (msg.sender_id && myClientId && msg.sender_id === myClientId) || false;
            if (fromSelf) { return; }
            currentVersion = msg.version || currentVersion;
            $('version').textContent = 'v' + currentVersion;
            if (msg.content && msg.content !== lastXml) {
              const isAiUpdate = msg.username === 'ai';
              const isExternalUpdate = msg.username === 'external';
              console.log(`[WS] Update from ${msg.username}, isAI: ${isAiUpdate}, isExternal: ${isExternalUpdate}, content length: ${msg.content.length}, prev length: ${lastXml.length}`);
              lastXml = msg.content;
              // For AI updates and external updates, always reload (not merge) since content is completely regenerated
              // For human updates, try merge first, then fallback to reload
              if (isAiUpdate) {
                // Always reload for AI updates
                console.log('[WS] Reloading editor with AI-generated XML');
                $('status').textContent = 'AI update received, reloading...';
                postToEditor({ action: 'load', autosave: 1, xml: lastXml, title: filePath });
                // Show visual feedback
                setTimeout(() => {
                  $('status').textContent = 'AI update applied';
                  setTimeout(() => { $('status').textContent = 'Connected'; }, 2000);
                }, 500);
              } else if (isExternalUpdate) {
                // Always reload for external file changes
                console.log('[WS] Reloading editor with externally modified file');
                $('status').textContent = 'File changed externally, reloading...';
                postToEditor({ action: 'load', autosave: 1, xml: lastXml, title: filePath });
                // Show visual feedback
                setTimeout(() => {
                  $('status').textContent = 'External change applied';
                  setTimeout(() => { $('status').textContent = 'Connected'; }, 2000);
                }, 500);
              } else {
                // Try merge first for human updates; fallback to reload
                try {
                  postToEditor({ action: 'merge', xml: lastXml });
                } catch {
                  postToEditor({ action: 'load', autosave: 1, xml: lastXml, title: filePath });
                }
              }
            } else {
              console.log(`[WS] Update ignored: content same or empty (same: ${msg.content === lastXml})`);
            }
          } else if (msg.type === 'ai_status') {
            addAiActivity(msg.job_id, msg.phase, msg.detail);
          }
        } catch (e) {
          console.error('bad ws message', e, ev.data);
        }
      };
    }

    function editorOrigin() {
      const iframe = $('editor');
      try {
        const url = new URL(iframe.getAttribute('src'), window.location.origin);
        return url.origin;
      } catch {
        return window.location.origin;
      }
    }
    function postToEditor(msg) {
      const iframe = $('editor');
      iframe.contentWindow.postMessage(JSON.stringify(msg), editorOrigin());
    }

    // AI Modal controls
    const aiOpen = $('ai-open');
    const aiClose = $('ai-close');
    const aiBackdrop = $('ai-backdrop');
    const aiModal = $('ai-modal');
    const aiRun = $('ai-run');
    const aiProvider = $('ai-provider');
    const aiModel = $('ai-model');
    const aiTemp = $('ai-temp');
    const aiSystem = $('ai-system');
    const aiPrompt = $('ai-prompt');
    const aiActivity = $('ai-activity');
    const aiActivityLog = $('ai-activity-log');
    const aiActivityClose = $('ai-activity-close');
    const aiActivityStream = $('ai-activity-stream');
    function openAi() {
      aiModal.style.display = 'block';
      aiBackdrop.style.display = 'block';
      if (!aiModel.value) {
        aiModel.value = aiProvider.value === 'openrouter' ? 'openrouter/anthropic/claude-3.5-sonnet' : 'llama3.1:latest';
      }
      aiPrompt.focus();
    }
    function closeAi() {
      aiModal.style.display = 'none';
      aiBackdrop.style.display = 'none';
    }
    function showAiActivity() {
      aiActivity.style.display = 'block';
    }
    function hideAiActivity() {
      aiActivity.style.display = 'none';
    }
    function addAiActivity(jobId, phase, detail) {
      showAiActivity();
      if (phase === 'stream') {
        // Append streaming content into the pre block
        aiActivityStream.textContent += detail;
        aiActivityStream.scrollTop = aiActivityStream.scrollHeight;
        return;
      }
      const row = document.createElement('div');
      const t = new Date();
      const hh = `${t.getHours()}`.padStart(2,'0');
      const mm = `${t.getMinutes()}`.padStart(2,'0');
      const ss = `${t.getSeconds()}`.padStart(2,'0');
      const stamp = `${hh}:${mm}:${ss}`;
      row.textContent = `[${stamp}] ${phase}: ${detail}`;
      aiActivityLog.appendChild(row);
      aiActivityLog.scrollTop = aiActivityLog.scrollHeight;
      aiJobs.set(jobId, { lastPhase: phase, createdAt: Date.now() });
      if (phase === 'done' || phase === 'error') {
        // auto-hide after a short delay
        setTimeout(() => {
          if (aiActivity.style.display !== 'none') {
            hideAiActivity();
            aiActivityLog.innerHTML = '';
            aiActivityStream.textContent = '';
          }
        }, 5000);
      }
    }
    if (aiOpen) aiOpen.onclick = (e) => { e.preventDefault(); openAi(); };
    if (aiClose) aiClose.onclick = closeAi;
    if (aiBackdrop) aiBackdrop.onclick = closeAi;
    if (aiActivityClose) aiActivityClose.onclick = hideAiActivity;
    if (aiRun) aiRun.onclick = async () => {
      if (!filePath) { alert('No file open'); return; }
      const prompt = aiPrompt.value.trim();
      if (!prompt) { alert('Enter an instruction'); return; }
      const provider = aiProvider.value;
      const model = aiModel.value.trim();
      if (!model) { alert('Enter a model'); return; }
      const temperature = aiTemp.value.trim() ? parseFloat(aiTemp.value.trim()) : undefined;
      const system = aiSystem.value.trim() || undefined;
      $('status').textContent = 'AI working...';
      showAiActivity();
      addAiActivity('local', 'request', `Sending to ${provider} (${model})`);
      try {
        const res = await fetch(addTokenToUrl(`/api/ai_modify?path=${encodeURIComponent(filePath)}`), {
          method: 'POST',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt, provider, model, temperature, system })
        });
        if (!res.ok) throw new Error(await res.text());
        const out = await res.json();
        // The server will broadcast via WS; but in case no WS, apply locally.
          if (!ws || ws.readyState !== WebSocket.OPEN) {
            lastXml = out.content || '';
            postToEditor({ action: 'load', autosave: 1, xml: lastXml, title: filePath });
            $('version').textContent = 'v' + (out.version || currentVersion);
          }
        $('status').textContent = 'AI applied';
        closeAi();
        addAiActivity('local', 'completed', 'Applied changes');
      } catch (e) {
        console.error(e);
        $('status').textContent = 'AI error';
        alert('AI error: ' + (e?.message || e));
        addAiActivity('local', 'error', e?.message || 'error');
      }
    };

    // If the iframe is same-origin (when you self-host draw.io), attach direct mouse tracking for precise cursors
    function attachSameOriginMouseTracking() {
      const iframe = $('editor');
      try {
        const childWin = iframe.contentWindow;
        const childDoc = childWin.document;
        // Accessing childDoc will throw if cross-origin; guard with try/catch
        if (!childDoc) return;
        let lastSentLocal = 0;
        childDoc.addEventListener('mousemove', (e) => {
          if (!ws || ws.readyState !== WebSocket.OPEN) return;
          const now = performance.now();
          if (now - lastSentLocal < 33) return;
          lastSentLocal = now;
          // Prefer coordinates relative to the drawing stage to remove toolbar offsets
          const stage = childDoc.querySelector('.geDiagramContainer') || childDoc.querySelector('#geDiagramContainer');
          if (stage) {
            const stageRect = stage.getBoundingClientRect();
            const nx = Math.max(0, Math.min(1, (e.clientX - stageRect.left) / Math.max(1, stageRect.width)));
            const ny = Math.max(0, Math.min(1, (e.clientY - stageRect.top) / Math.max(1, stageRect.height)));
            ws.send(JSON.stringify({ type: 'cursor', basis: 'stage', x: nx, y: ny }));
          } else {
            const overlayRect = $('overlay').getBoundingClientRect();
            const iframeRect = iframe.getBoundingClientRect();
            const absX = iframeRect.left + e.clientX;
            const absY = iframeRect.top + e.clientY;
            const nx = Math.max(0, Math.min(1, (absX - overlayRect.left) / Math.max(1, overlayRect.width)));
            const ny = Math.max(0, Math.min(1, (absY - overlayRect.top) / Math.max(1, overlayRect.height)));
            ws.send(JSON.stringify({ type: 'cursor', x: nx, y: ny }));
          }
        }, { passive: true });
      } catch {
        // Not same-origin; ignore
      }
    }

    // Listen to messages from the editor
    let waitingExportForSave = false;

    window.addEventListener('message', async (evt) => {
      // Must be stringified JSON
      let data = null;
      try {
        data = JSON.parse(evt.data);
      } catch {
        return;
      }
      // Editor ready lifecycle
      if (data.event === 'init' || data.action === 'init') {
        isEditorReady = true;
        // Load initial xml once editor is ready
        if (lastXml !== null) {
          postToEditor({ action: 'load', autosave: 1, xml: lastXml, title: filePath });
        }
        // Request event stream (selection/mouse) from embed
        try {
          postToEditor({ action: 'configure', config: { listen: true, events: true, eventsEnabled: true } });
        } catch {}
        // Try to attach direct listeners if same-origin
        attachSameOriginMouseTracking();
        return;
      }
      // Selection changes from editor (best-effort API)
      if (data.event === 'selectionChanged' && Array.isArray(data.cells)) {
        try {
          if (ws && ws.readyState === WebSocket.OPEN) {
            const ids = data.cells.map(c => (c && typeof c === 'object') ? (c.id || '') : (typeof c === 'string' ? c : '')).filter(Boolean);
            ws.send(JSON.stringify({ type: 'selection', ids }));
          }
        } catch {}
      }
      // Mouse move events from embed; forward if present
      if ((data.event === 'mouseMove' || data.event === 'mousemove' || data.action === 'mouseMove') && typeof data.x === 'number' && typeof data.y === 'number') {
        try {
          if (ws && ws.readyState === WebSocket.OPEN) {
            const rect = $('overlay').getBoundingClientRect();
            const nx = Math.max(0, Math.min(1, (data.x - rect.left) / Math.max(1, rect.width)));
            const ny = Math.max(0, Math.min(1, (data.y - rect.top) / Math.max(1, rect.height)));
            ws.send(JSON.stringify({ type: 'cursor', x: nx, y: ny }));
            lastEmbedMoveAt = performance.now();
          }
        } catch {}
      }
      console.log('data', data);
      // The editor asks us to save current XML
      if (data.event === 'save' || data.action === 'save' || data.event === 'autosave') {
        try {
          $('status').textContent = 'Saving...';
          let xml = data.xml || '';
          // Fallback path: request export if xml not provided
          if (!xml) {
            waitingExportForSave = true;
            postToEditor({ action: 'export', format: 'xml' });
            return; // continue when we receive export
          }
          lastXml = xml;
          // Broadcast via WS
          if (ws && ws.readyState === WebSocket.OPEN) {
            selfUpdateToken++;
            ws.send(JSON.stringify({ type: 'replace', version: currentVersion, content: xml, self: selfUpdateToken }));
          }
          // Persist via HTTP (no automatic commit)
          const resp = await fetch(addTokenToUrl(`/api/file?path=${encodeURIComponent(filePath)}`), {
            method: 'PUT',
            credentials: 'include',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content: xml }),
          });
          if (!resp.ok) {
            const msg = await resp.text();
            $('status').textContent = `Save failed: ${msg || resp.status}`;
            return;
          }
          $('status').textContent = 'Saved';
          postToEditor({ action: 'status', modified: false });
          return;
        } catch (e) {
          $('status').textContent = `Save error`;
          return;
        }
      }
      // Editor export response (used when xml not included in save/autosave)
      if (data.event === 'export') {
        if (waitingExportForSave) {
          waitingExportForSave = false;
          const xml = data.data || data.xml || '';
          if (!xml) {
            $('status').textContent = 'Export failed';
            return;
          }
          (async () => {
            try {
              lastXml = xml;
              if (ws && ws.readyState === WebSocket.OPEN) {
                selfUpdateToken++;
                ws.send(JSON.stringify({ type: 'replace', version: currentVersion, content: xml, self: selfUpdateToken }));
              }
              // Persist via HTTP (no automatic commit)
              const resp = await fetch(addTokenToUrl(`/api/file?path=${encodeURIComponent(filePath)}`), {
                method: 'PUT',
                credentials: 'include',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ content: xml }),
              });
              if (!resp.ok) {
                const msg = await resp.text();
                $('status').textContent = `Save failed: ${msg || resp.status}`;
                return;
              }
              $('status').textContent = 'Saved';
              postToEditor({ action: 'status', modified: false });
            } catch {
              $('status').textContent = 'Save error';
            }
          })();
          return;
        }
      }
      // Exit from editor
      if (data.event === 'exit' || data.action === 'exit') {
        const storedToken = localStorage.getItem('drawio_token');
        location.href = storedToken ? `/?token=${encodeURIComponent(storedToken)}` : '/';
        return;
      }
    });

    $('editor').addEventListener('load', () => {
      // Attempt same-origin tracking as soon as the iframe loads
      attachSameOriginMouseTracking();
      // The editor will send 'init' shortly; we don't send 'load' until then
    });

    // Presence cursors
    function ensureCursor(username, color) {
      if (username === myUsername) return;
      if (cursors.has(username)) return;
      const el = document.createElement('div');
      el.className = 'cursor';
      const dot = document.createElement('div');
      dot.className = 'dot';
      dot.style.background = color;
      dot.style.borderColor = color;
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = username;
      const selEl = document.createElement('div');
      selEl.className = 'sel';
      selEl.style.display = 'none';
      el.appendChild(dot);
      el.appendChild(label);
      el.appendChild(selEl);
      $('overlay').appendChild(el);
      cursors.set(username, { el, color, selEl });
    }
    function removeCursor(username) {
      const c = cursors.get(username);
      if (!c) return;
      c.el.remove();
      cursors.delete(username);
    }
    function getOverlayStageRect() {
      const iframe = $('editor');
      try {
        const childDoc = iframe.contentWindow.document;
        const stage = childDoc.querySelector('.geDiagramContainer') || childDoc.querySelector('#geDiagramContainer');
        if (!stage) return null;
        const iframeRect = iframe.getBoundingClientRect();
        const stageRect = stage.getBoundingClientRect();
        const overlayRect = $('overlay').getBoundingClientRect();
        return {
          left: (iframeRect.left + stageRect.left) - overlayRect.left,
          top: (iframeRect.top + stageRect.top) - overlayRect.top,
          width: stageRect.width,
          height: stageRect.height
        };
      } catch { return null; }
    }

    function moveCursor(username, nx, ny, basis) {
      const c = cursors.get(username);
      if (!c) return;
      const overlay = $('overlay');
      const rect = overlay.getBoundingClientRect();
      let x, y;
      if (basis === 'stage') {
        const s = getOverlayStageRect();
        if (s) {
          x = s.left + nx * s.width;
          y = s.top + ny * s.height;
        } else {
          x = nx * rect.width;
          y = ny * rect.height;
        }
      } else {
        x = nx * rect.width;
        y = ny * rect.height;
      }
      c.el.style.left = x + 'px';
      c.el.style.top = y + 'px';
    }
    // Fallback: parent-document tracking for when embed doesn't emit mouseMove
    let lastSent = 0;
    document.addEventListener('mousemove', (e) => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      const now = performance.now();
      // If we recently received an embed mouse event, skip fallback to avoid double-sends
      if (now - lastEmbedMoveAt < 80) return;
      if (now - lastSent < 33) return; // ~30fps throttle
      const overlay = $('overlay');
      const rect = overlay.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (x < 0 || y < 0 || x > rect.width || y > rect.height) return;
      lastSent = now;
      const nx = x / Math.max(1, rect.width);
      const ny = y / Math.max(1, rect.height);
      ws.send(JSON.stringify({ type: 'cursor', x: nx, y: ny }));
    });

    // Commit button handler
    $('commit-btn').addEventListener('click', async () => {
      if (!filePath) {
        $('status').textContent = 'No file to commit';
        return;
      }
      
      const commitMessage = $('commit-message').value.trim();
      
      try {
        $('status').textContent = 'Saving and committing...';
        $('commit-btn').disabled = true;
        
        // First, save the current content to ensure it's up to date
        // Get current content from editor
        let xml = lastXml;
        if (!xml) {
          // Request export if we don't have current content
          const exportPromise = new Promise((resolve, reject) => {
            const timeout = setTimeout(() => reject(new Error('Export timeout')), 5000);
            const handler = (evt) => {
              try {
                const data = JSON.parse(evt.data);
                if (data.event === 'export') {
                  clearTimeout(timeout);
                  window.removeEventListener('message', handler);
                  resolve(data.data || data.xml || '');
                }
              } catch {}
            };
            window.addEventListener('message', handler);
            postToEditor({ action: 'export', format: 'xml' });
          });
          xml = await exportPromise;
        }
        
        // Save the file first to update the room
        const saveResp = await fetch(addTokenToUrl(`/api/file?path=${encodeURIComponent(filePath)}`), {
          method: 'PUT',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content: xml }),
        });
        
        if (!saveResp.ok) {
          const msg = await saveResp.text();
          $('status').textContent = `Save failed: ${msg || saveResp.status}`;
          return;
        }
        
        // Now create the commit
        const resp = await fetch(addTokenToUrl(`/api/versions/checkpoint?path=${encodeURIComponent(filePath)}`), {
          method: 'POST',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: commitMessage || undefined }),
        });
        
        if (!resp.ok) {
          const msg = await resp.text();
          $('status').textContent = `Commit failed: ${msg || resp.status}`;
          return;
        }
        
        const result = await resp.json();
        $('status').textContent = 'Committed';
        $('commit-message').value = ''; // Clear message field
        setTimeout(() => {
          if ($('status').textContent === 'Committed') {
            $('status').textContent = 'Connected';
          }
        }, 2000);
      } catch (e) {
        $('status').textContent = `Commit error: ${e.message}`;
      } finally {
        $('commit-btn').disabled = false;
      }
    });
    
    // Allow Enter key in commit message to trigger commit
    $('commit-message').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        $('commit-btn').click();
      }
    });

    refreshMe();
    loadInitial().then(connectWS);
  </script>
</body>
</html>


